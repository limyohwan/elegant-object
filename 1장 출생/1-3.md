# 생성자에 코드를 넣지 마세요

### 인자에 손대지 말라(don't touch the arguments)
- 주 생성자는 객체 초기화 프로세스를 시작하는 유일한 장소이기 때문에 인자들은 완전(누락x, 중복x)해야 함

```java
//잘못된 예시
class Cash {
    private int dollars;

    Cash(String dlr) {
        this.dollars = Integer.parseInt(dlr);
    }
}
```

- 객체 초기화시 '코드가 없어야(code-free)'하고 인자를 건드려서는 안됨
- 인자들을 다른 타입의 객체로 감싸거나 가공하지 않은 형식(raw form)으로 캡슐화해야 함

```java
class Cash {
    private Number dollars;

    Cash(String dlr) { //부 ctor
        this(new StringAsInteger(dlr));
    }

    Cash(Number dlr) {//주 ctor
        this.dollars = dlr;
    }
}

class StringAsInteger implements Number {
    private String source;

    StringAsInteger(String src) {
        this.source = src;
    }

    int intValue() {
        return Integer.parseInt(this.source);
    }
}
```

- 실제로 intValue()를 호출하는 시점까지 객체의 변환 작업을 연기함
- 진정한 객체지향에서 인스턴스화(instantiation)란 `더 작은 객체들을 조합해서 더 큰 객체를 만드는 것`
- 처음 할일은 객체를 인스턴스화하는 것, 두번째 할일은 객체가 작업을 하게 만드는 것 -> 두 단계가 겹쳐서는 안됨
- 생성자에 코드가 없을 경우 성능 최적화가 더 쉬움 -> 코드의 실행 속도 향상

```java
//#1
class StringAsInteger implements Number {
    private String text;

    StringAsInteger(String txt) {
        this.text = txt;
    }

    int intValue() {
        return Integer.parseInt(this.text);
    }
}

//#2
class StringAsInteger implements Number {
    private int num;

    StringAsInteger(String txt) {
        this.num = Integer.parseInt(txt);
    }

    int intValue() {
        return this.num;
    }
}
```

- ctor를 직접 파싱을 수행하는 #2의 경우 최적화가 불가능 함
- 객체를 만들 때마다 매번 파싱이 수행되기 때문에 실행 여부를 제어할 수 없으며 intValue를 호출할 필요가 없는 경우에도 CPU를 소모하게 됨
- 인자를 전달된 상태 그대로 캡슐화하고 나중에 요청이 있을 때(on demand) 파싱하도록 하면 클래스의 사용자들이 파싱 시점을 자유롭게 결정할 수 있음

```java
class CachedNumber implements Number {
    private Number origin;
    private Collection<Integer> cached = new ArrayList<>(1); //null피하기

    public CachedNumber(Number num) {
        this.origin = num;
    }

    public int intValue() {
        if(this.cached.isEmpty()) {
            this.cached.add(this.origin.intValue());
        }
        return this.cached.get(0);
    }
}
```

- 데코레이터(decorator)를 추가하여 파싱이 여러 번 수행되지 않도록 캐싱 가능
- 객체를 인스턴스화하는 동안에는 객체를 만드는(build) 일 이외에는 어떤 일도 수행하지 않음
- 객체의 메서드 수행 과정을 제어하고 최적화 가능
- 객체는 요청을 받을 때만 행동하고 그전에는 어떤 일도 하지 않음(lazy)
- ctor 내부에 로직을 작성하게 되면 추후 리팩토링 시 어려움을 겪음
- 가벼운 ctor는 설정하기 쉽고 투명하게 사용 가능하기 때문에 객체를 더 빠르게 만들 수 있음

### 1-3 느낀점
1. 주생성자와 부생성자의 연장선의 느낌이였으며 lazy호출과 캡슐화에 대해서 좀더 생각해볼 수 있었고 서로 다른 객체들끼리의 협력에 대해서도 고민해 볼 수 있었다.
2. 예전에 객체를 캐싱한다는 것에 대해서 생각을 해보았고 그때 내가 해결한 방법에 대해 생각해 보았다.

```java
public class CodeService {
    private static final List<CodeDto> statuses = new ArrayList<>();;

    public List<CodeDto> getStatuses() {
        if(statuses.isEmpty()){
            Arrays.stream(statuses.values())
                    .map(st -> statuses.add(new CodeDto(st.name(), st.getTitle())))
                    .collect(Collectors.toList());
        }
        return statuses;
    }
}
```

enum 타입 값을 코드 형식으로 리턴해주는 로직이 있었는데 이 때 statuses 리스트에 값이 없으면 리스트를 생성한 후 statuses를 리턴하고 값이 있으면 바로 리턴하는 코드를 작성한 적이 있다.
그당시 이게 맞나라는 생각을 하며 코드를 작성했었는데 책에서 비슷한 내용이 나와서 뿌듯한 기분이 들었다.
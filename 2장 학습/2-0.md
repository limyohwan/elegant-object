# 학습
- 객체를 다른 객체와 상호작용할 수 있도록 준비시키기 위해 필요한 몇 가지 원칙을 설명
- 요약 -> `객체는 작아야 한다`
- 작은 객체 = 우아한 동시에 유지보수 가능한 객체

### 2장 느낀점
1. 클래스를 설계하면서 4개 이하의 상태를 가지게 하는 것은 매우 어려웠다. 
결국에는 데이터를 사용하여 클래스를 설계하다 보니 최종적으로 4개 이상의 상태를 가질 수 밖에 없었다.
개인적인 생각으로는 상태를 또 다른 객체로 만들어 나누는 것은 재사용성에 분명 유용하겠지만 단순하게 보았을때 유지보수에 용이할까라는 생각이 들었다.
이 부분은 계속 고민하며 해결해야하는 문제라고 느껴졌다.

2. 위와 같이 또 계속 고민하며 해결해야할 문제중 하나로 인터페이스의 설계가 있었다.
service 계층을 인터페이스로 할 것인가 아닌가에 대해 고민을 하다 그냥 클래스로 설계를 하였다.
물론 그냥 클래스로 설계를 했다가 후회한 부분도 있었다.

```java
public class SmsSender(){
    void sendMessage(){
        //...
    }
}
```

그냥 단순히 메시지 보내는 것을 클래스로 설계했는데 이 메시지 보내는 부분이 문자메시지가 아니라 메일로 바뀌어 버렸다.
그래서 SmsSender 대신 MailSender를 만들고 다시 다 객체를 생성하는 부분부터 변경했어야 했다.

```java
public class MailSender(){
    void sendMessage(){
        //...
    }
}
```

이렇게하며 느낀게 확실히 변경될 가능성이 큰 부분은 인터페이스로 설계하는게 맞는거 같다고 생각했다.

```java
public interface MessageSender(){
    void sendMessage();
}
```

최종적으로는 아래와 같은 코드로 수정하였다.

```java
public class MailSender implements MessageSender {
    @Override
    void sendessage(){
        //...
    }
}

public class SmsSender implements MessageSender {
    @Override
    void sendessage(){
        //...
    }
}
```

위와 같이 구성하여 스프링 컨테이너를 이용한 의존성 주입을 사용하여 쉽게 구현체를 변경할 수 있었다.

3. 메서드의 이름을 짓는 법은 아직까지 확실하게 이해하지 못했다.
자바 관례상 대부분의 메서드들은 동사로 시작하기 때문에 과연 이 책의 가이드에 따라 무조건적으로 따라야할까라는 의문이 들었다.
관례를 따르고 팀과의 코드컨벤션을 지키며 유지하는게 제일 좋은 베스트 프랙티스일 것 같다.

4. 상수 사용을 위한 객체를 만드는 것보다는 final class나 enum을 활용하는게 더 가독성과 유지보수성이 좋을 것 같다고 생각한다.

5. null 값으로 무언가를 분기치는 것은 되게 안좋은 시도인것을 깨달았다.
이번 프로젝트에서 join이 맺어져있으면 특정 값, join 값이 없으면 특정 값 이런식으로 분기를 쳐서 로직을 작성하였는데 모든 로직에 if ** != null이 들어가 코드를 어지럽혔고 코드를 작성한 나조차도 if ** != null이 어떤 의미인지 헷갈리게 되었다.
차라리 특정 타입 값이라도 넣어 if ** == goodType 이런 방법으로라도 처리를 했으면 훨씬 유지보수하기 용이했을 것이다.
잘못된 방식으로 처리를 하여 결국에는 //주석을 추가로 작성하여야 했다.

6. 모의 객체 대신 페이크 객체는 좋은 시도로 보인다.
mock을 사용하게 되면 결국 변경이 있을 때 테스트를 찾아가 일일이 바꿔야 되는데 페이크 객체가 내장되어있으면 애초에 바로 눈에 띄게 쉽게 바꿀 수 있을 것 같다.
# -er로 끝나는 이름을 사용하지 마세요

### 클래스에 적합한 이름 짓기
- 클래스의 이름은 객체가 노출하고 있는 기능(functionality)에 기반하면 안됨
- `무엇을 하는지(what he does)`가 아니라 `무엇인지(what he is)`에 기반해야 함

```java
//나쁜 예시
class CashFormatter {
    private int dollars;
    
    CashFormatter(int dlr) {
        this.dollars = dlr;
    }

    public String format() {
        return String.format("$ %d", this.dollars);
    }
}

//좋은 예시
class Cash {
    private int dollars;

    Cash(int dlr) {
        this.dollars = dlr;
    }

    public String usd() {
        return String.format("$ %d", this.dollars);
    }
}
```

### 클래스
- 객체의 팩토리(factory)
- 객체를 생성 = 클래스가 객체를 인스턴스화함(instantiate)
- 필요할 때 객체를 꺼낼 수 있고, 필요하지 않은 객체를 반환할 수 있는 객체의 웨어하우스(warehouse)
- 객체의 능동적인 관리자(active manager)
- 객체의 어머니

```java
class Cash {
    public Cash(int dollars) {
        //...
    }
}

Cash five = new Cash(5);
```

### new 연산자
- 충분히 강력하지 않으며 new 연산자로 할 수 있는 유일한 작업은 객체(object)라고 불리는 클래스의 인스턴스(instance)를 생성하는 것
- 유사한 객체의 존재, 재사용 여부를 확인하지 않으며 new가 동작하는 방식을 변경할 수 있는 어떤 매개변수도 제공하지 않음
- 객체의 팩토리를 제어할 수 있는 원시적인 수단
- 클래스의 정적 메서드

### 팩토리 패턴
- 개념적으로 new 연산자와 동일함
- new 연산자를 보다 유연하고 강력하게 만들 수 있음

```java
class Shapes {
    public Shape make(String name){
        if(name.equals("circle")) {
            return new Circle();
        }
        if(name.equals("rectangle")) {
            return new Rectangle();
        }
        throw new IllegalArgumentException("not found");
    }
}
```

### 객체
- `역량(capability)`으로 특정지어져야 함
- 외부 세계와 내부 세계를 이어주는 연결장치(connector)가 아니라 캡슐화된 데이터의 `대표자(representative)`임

### 1-1 느낀점
1. 내가 주로 사용하는 스프링에서의 클래스 이름 정하기에 대해 생각해 보았다. 
스프링의 이름 짓기는 조금 더 까다로웠던거 같다.
스프링 빈(컴포넌트) 이름을 지을때 많이 고민했던 부분 중 Jwt관련 컴포넌트의 이름을 지을때 Jwt로 할지 JwtProvider로 할지 고민을 많이하고 JwtProvider에서 Jwt로 변경을 했었으나 컴포넌트는 상태 값을 가질 수 없기 때문에 JwtProvider가 더 적합하다고 생각하여 다시 리팩터링을 한 기억이있다.
클래스나 메서드 등 네이밍 짓는 룰은 같이하는 팀원들과 조율을 하여 진행하는게 제일 좋을것 같다고도 생각이 들었다.

2. 생성자(new 연산자)만으로 내가 생각하는 객체가 어떻게 쓰여서 생성될지 모를정도로 복잡한 객체가 있었다.
```java
public Information(InformationCondition condition){};
public Information(PostCondition condition){};
```

위와 같이 생성자를 만들었을 때 이게 어디에 어떻게 쓰일지 내가 만들고도 예상하기가 힘들것 같았다.(실제는 조금 더 복잡하였고 조금 축약하였음)

```java
public static Information createInformationForSearchByInformationCondition(InformationCondition condition){};
public static Information createInformationForSearchByPostCondition(PostCondition condition){};
```

이런 식으로 어디에 어떻게 쓰일지에 관하여 조금 명확하게 이름을 가진 메서드로 만들어 구분하기 쉽게 만들었다.


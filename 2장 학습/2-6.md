# 불변 객체로 만드세요
- 모든 클래스를 상태 변경이 불가능한 불변 클래스(immutable class)로 구현하면 유지보수성을 크게 향상 시킬 수 있음
- 불변성 역시 크기가 작고, 응집력이 높으며, 느슨하게 결합되고, 유지보수하기 쉬운 클래스를 만들 수 있또록 함

```java
//가변 객체
class Cash {
    private int dollars;

    public void setDollars(int val) {
        this.dollars = val;
    }
}
//불변 객체
class Cash {
    private final int dollars;
    Cash(int val) {
        this.dollars = val;
    }
}
```

- final 키워드를 추가해 프로퍼티의 값을 수정할 경우 컴파일 에러 발생 
- 불변 객체는 필요한 모든 것을 내부에 캡슐화하고 변경할 수 없도록 통제

```java
//가변 객체
class Cash {
    private int dollars;

    public void mul(int factor) {
        this.dollars *= factor;
    }
}
//불변 객체
class Cash {
    private final int dollars;
    public Cash mul(int factor) {
        return new Cash(this.dollars * factor);
    }
}
```

- 불변 객체는 자기 자신을 수정할 수 없으므로 항상 새로운 객체를 생성해서 반환해야 함

```java
//가변 객체
Cash five = new Cash(5);
five.mul(10);
System.out.println(five);
//불변 객체
Cash five = new Cash(5);
Cash fifty = five.mul(10);
System.out.println(fifty);
```

- five는 fifty가 될 수 없으므로 항상 다른 객체를 인스턴스화 해야 함
- five 가변 객체는 '5달러'처럼 행동할 것이라고 기대하지만 예상과 달리 '50달러'처럼 행동 함
- 불변 객체는 지연 로딩(lazy loading)이 불가능 함

```java
class Page {
    private final String uri;
    private String html;
    Page(String address) {
        this.uri = address;
        this.html = null;
    }
    public String content() {
        if(this.html == null) {
            this.html = /* 네트워크로부터 로드함 */
        }
        return this.html;
    }
}
```

- 객체를 생성하는 시점에 html은 아무것도 저장하고 있지 않으며 content() 메서드를 최초로 호출하는 시점에 저장됨
- content를 다시 호출하면 저장되어 있는 html을 반환함

```java
@OnlyOnce
public String content() {
    return /* 네트워크로부터 로드함 */;
}
```

- 언어적인 차원에서 객체를 불변으로 유지하면서 지연 로딩을 구현할 수 있도록 제공해야 한다고 생각함

### 식별자 가변성(Identity Mutability)
- 불변 객체에는 '식별자 가변성(identity mutablity)의 문제가 없음
- 이 문제는 동일해 보이는 두 객체를 비교한 후 한 객체의 상태를 변경할 때 나타남

```java
Map<Cash, String> map = new HashMap<>();
Cash five = new Cash("$5");
Cash ten = new Cash("$10");
map.put(five, "five");
map.put(ten, "ten");
five.mul(2);
System.out.println(map);//{$10 => "five", $10 => "ten"}
```

- five 와 ten이라는 동일하지 않은 두 객체를 생성했지만 mul() 메서드를 호출하여 five 객체의 상태를 변경
- map은 변경이 일어났다는 사실을 인식하지 못하고 중복을 제거할 기회를 제공 받지 못하여 혼란스러운 상태의 map이 남겨지게 됨

```java
map.get(five); // "ten"과 "five" 중 하나가 반환 됨
```

- 매우 심각하고 찾기 어려운 버그로 이어질 수 있음
- 불변 객체를 사용하면 상태 변경이 불가능하기 때문에 '식별자 가변성' 문제가 발생하지 않음

### 실패 원자성(Failure Atomicity)
### 시간적 결합(Temporal Coupling)
### 부수효과 제거(Side effect-free)
### NULL 참조 없애기
### 스레드 안전성
### 더 작고 더 단순한 객체